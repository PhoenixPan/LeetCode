## Test case
```
[1,3,5,6]
5
[1,3,5,6]
2
[1,3,5,6]
7
[1,3,5,6]
0
[1,3,5,6]
3
[0]
0
[1]
0
[1]
2
[1,3] 
0
[1,3] 
2
[1,3] 
4
[1,2,3,4,5,6,8,9]
7
[1,2,3,4,5,6,8,9]
0
[1,2,3,4,5,6,8,9]
10
```

## Solution 1: accepted 7ms

Normal iteration.  
Time: O(n)  
Space: O(1)  

```java
public int searchInsert(int[] nums, int target) {
    int prev = Integer.MIN_VALUE;
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] == target)
            return i;
        else if (target > prev && target < nums[i])
            return i; 
    }
    return nums.length;
}
```

## Solution 2: accepted 7ms

Binary search.    
Time: O(logn)  
Space: O(1)  
```java
public int searchInsert(int[] nums, int target) {
  if (nums == null || nums.length < 1) {
    return -1;
  }
      
  int start = 0;
  int end = nums.length - 1;

  if (target <= nums[0]) return 0;
  if (target > nums[end]) return end + 1;

  while (start + 1 < end) {
    int mid = start + (end - start) / 2;      
    if (nums[mid] == target) {
      return mid;
    } else if (nums[mid] > target) {
      end = mid;    
    } else {
      start = mid;
    }
  }

  // start and end will only differ by 1, so we could just use end
  // if (nums[end] == target) return end;
  // return start + 1;
  
  return end;      
}
```

without template: 
```java
public int searchInsert(int[] nums, int target) {
  if (nums == null || nums.length < 1) {
    return -1;
  }
      
  int start = 0;
  int end = nums.length - 1;

  if (target > nums[end]) return end + 1;
  
  while (start < end) {
    int mid = start + (end - start) / 2;      
    if (nums[mid] == target) {
      return mid;
    } else if (nums[mid] > target) {
      end = mid;    
    } else {
      start = mid + 1;
    }
  }

  return start;
}
```