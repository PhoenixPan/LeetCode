## Solution 2: accepted

DFS.  

```java
public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> result = new ArrayList<List<Integer>>();
    List<Integer> list = new ArrayList<Integer>();
    subsetsHelper(result, list, nums, 0);
    return result;
}

public void subsetsHelper(List<List<Integer>> result,
                          List<Integer> list,
                          int[] nums,
                          int pos) {
    result.add(new ArrayList<Integer>(list));
    for (int i = pos; i < nums.length; i++) {
        list.add(nums[i]);
        subsetsHelper(result, list, nums, i + 1);
        list.remove(list.size() - 1);
    }
}
```

## Solution 2: accepted 3ms


`it.next()` will cause ConcurrentModificationException, because the length of result will change as we add new elements in. So we need the temp list to store the newly generated elements. 

```java
public List<List<Integer>> subsets(int[] nums) {

  List<List<Integer>> result = new ArrayList<List<Integer>>();
  result.add(new ArrayList<>());
  if (nums.length < 1) return result;
  Arrays.sort(nums);

  for (int i : nums) {
    Iterator<List<Integer>> it = result.iterator();
    List<List<Integer>> temp = new ArrayList<List<Integer>>();
    // if we use it.next() directly, it cause "ConcurrentModificationException"
    // because the length of result will change as we add new elements in
    while (it.hasNext()) {
      List<Integer> copy = new ArrayList<Integer>(it.next());
      copy.add(i);
      temp.add(copy);
    }
    result.addAll(temp);
  }

  return result;
}
```
