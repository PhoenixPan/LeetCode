## Solution 1

1. No repeated remainder: so the maximum loop is K, otherwise we will have a duplicated remainder. Another approach is to use a list to store appeared remainder but it's less efficient.  
2. 同余定理

Time complexity: O(n)  
Space complexity: O(1) 

```java
class Solution {
    public int smallestRepunitDivByK(int K) {
        if (K % 2 == 0 || K % 5 == 0) return -1;
        int remainder = 0;
        for (int N = 1; N <= K; N++) {
            remainder = (remainder * 10 + 1) % K;
            if (remainder == 0) {
                return N;
            }
        }
        return -1;
    }
}
```

## Solution 2

Overflow

Time complexity: O(n)  
Space complexity: O(1)  

```java
class Solution {
    public boolean queryString(String S, int N) {
        int result = -1;
        for (int N = 1; N < Integer.MAX_VALUE && N > 0; N = N * 10 + 1) {
          if (N % K == 0) {
            return Integer.toString(N).length();
          }
        }
        return result;
    }
}
```

```javascript
var smallestRepunitDivByK = function(K) {
    var mods = [];
    for (var N = 1;;N = N * 10 + 1) {
        var mod = N % K;
        if (mod === 0) {
            return N.toString().length;
        }
        if (mods.indexOf(mod) > 0) {
            break;
        }
        mods.push(mod);
    }
    return -1;
};
```

## Solution 3

BigInteger Not accepted

```java
class Solution {
    public boolean queryString(String S, int N) {
        BigInteger mod = new BigInteger("-1");
        ArrayList<BigInteger> mods = new ArrayList<>();
        for (BigInteger N = new BigInteger("1");; N = N.multiply(new BigInteger("10")).add(new BigInteger("1"))) {
        mod = N.mod(new BigInteger(K + ""));
        mods.add(mod);
        if (mod.equals(new BigInteger("0"))) {
            return N.toString().length();
        }
        if (!mods.contains(mod)) {
            break;
        }
        }
        return -1;
    }
}
```