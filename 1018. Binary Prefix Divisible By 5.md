## Solution 1
Similar to question 1015 Smallest Integer Divisible by K.  In this question, as it's binary, so the induction rule is different from decimalism:  

```
011  = 2^2 * 0 + 2^1 * 1 + 2^0 * 1 = 3
0111 = 011 * 2 + 2^0 * 1 (the extra bit added at the end) 
     = 011 * 2 + 2^0 * 1
     = (2^2 * 0 + 2^1 * 1 + 2^0 * 1) * 2 + 2^0 * 1
     = 2^3 * 0 + 2^2 * 1 + 2^1 * 1 + 2^0 * 1
     = 7
```
Since we always append the extra digit (0 or 1) at the end, we need to multiply 2^0 = 1 by the extra digit. Since multiply by one could be ignored, we will simply add up the extra digit, and get  `next = pre * 2 + bit`.  

Next, we prove that we don't need to record the number and we only need to keep its remainder:  

At fundamental level, we know that:  
```
r = n % k
n % k = (r + m * k) % k
n % k = r % k
```
In this question, we have:  
```
r = n % k; 
n = m * k + r; 
2 * n + bit = 2 * m * k + 2 * r + bit; 
(2 * n + bit) % k = (2 * r + bit) % k;
```


Time complexity: O(n)  
Space complexity: O(1)  

```java
class Solution {
    public List<Boolean> prefixesDivBy5(int[] A) {
        List<Boolean> result = new ArrayList<>();
        int r = 0;
        for (int bit : A) {
            r = (r * 2 + bit) % 5;
            result.add(r % 5 == 0);
        }
        return result;
    }
}
```